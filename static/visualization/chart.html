

    <script type='text/javascript' src='http://www.google.com/jsapi'></script>
    <script type="text/javascript"
        src='https://www.google.com/jsapi?autoload={"modules":[{"name":"visualization","version":"1"}]}'>
    </script>

    <script type="text/javascript" src="http://code.jquery.com/jquery-1.9.0.min.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/ui/1.10.0/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/spin.js" ></script>

    <link rel="stylesheet" media="all" type="text/css" href="http://code.jquery.com/ui/1.10.0/themes/smoothness/jquery-ui.css" />
    <link rel="stylesheet" media="all" type="text/css" href="/static/css/dark.css" />

    <!-- High charts / High stocks -->
    <script src="js/highcharts/js/highstock.js"></script>
    <script src="js/highcharts/js/modules/exporting.js"></script>
    
    <style> 
      .container {
        /* border:2px solid #ccc;*/ 
        /*width:300px;*/
        height: 100px; 
        overflow-y: scroll; 
/*        margin-bottom: 5px;*/
      }
      
      .chart-type {
        border-top: solid 1px #444;
        border-bottom: solid 1px #444;
        padding: 7px 0;
        margin: 7px 0;
      }
      
      .chart-type select {
        color: #fff;
        background-color: #444;
        -webkit-appearance: menulist;
        box-sizing: border-box;
        -webkit-box-align: center;
        border: 1px solid #333;
/*        border-image: initial;*/
        white-space: pre;
        -webkit-rtl-ordering: logical;
        color: black;
        background-color: white;
        cursor: default;
      }
    </style>

    <script type='text/javascript'>

    /*
     NOTE : The caching of the datatable is pretty basic and essentially amount to storing a set
     number of retrieves on the browser side and generating an appropriate dataview from the
     data. If certain data is not available, then a call to the viz service is made.

     [1] The cache is currently implemented as a multi level cache. There's the overview data at the lowest resolution
     which is actually indicated by the highest stride factor. The stride factor (or zoom factor) decides the
     levels in the cache tree. Caching is done at level 1, level 2, level 4, level8 .. and overview level.
     No of blocks used in caching increase as one goes down the tree. So overview has 1 cache block and zoom level
     1 has the highest number of blocks. Blocks are of certain size e.g 4096. The container is always asked to fetch these
     4096 byte blocks and if the current view overlaps two subsequent 4096 blocks, two calls will be made
     to fetch each of those blocks. The figure of 4096 (or 1024 or whatever) is an approximation and the actual block
     returned by coverage may be different in size if the instrument has a non uniform data feed.

     [2] The stride_factor and zoom factor are used interchangeably. When stride_factor reduces ( ..3,2,1) the
     data resolution increases and there fore the zoom increases. So zoom = 1 is the highest and subsequent levels
     zoom out.

     [3] The blocks of cached data are arranged at boundaries aligned by the end_time. So if there are 90 records in total
     and the block size is 40, the three data blocks will have sizes [10,40,40]

     */

    // Global variables
    var graph, table, dataTable, dataTable_overview, dp_id, dp_id_token, dp_metadata, dataView_overview;
    var data_series_overview;
    var dataTable_overview_stride_factor = 1;
    var graph_visible_start_date, graph_visible_end_date, graph_x_res, avg_data_rate, curr_stride_factor = 1;
    var dataTable_parameters = []; // ['temp', 'pressure', 'conductivity'];

    var container_server = "http://" + window.location.host;
    var first_draw_flag = true;
    //var viz_params = {};
    var curr_graph_type = "line";
    //var supported_graph_type = ['AnnotatedTimeLine', 'Table', 'LineGraph', 'AreaChart', 'ComboChart'];
    var supported_graph_type = ['line', 'area', 'spline', 'scatter', 'table'];
    var overview_reqId = 9;
    var graph_spinner

    // cache
    var dataTable_cache_block_size = 1024, dataTable_cache_block_time_period;
    var dataTable_level_trigger = 1; // when user view crosses these zoom / stride levels (1 is highest), resolution of data changes
    var dataTable_cache = {}; // stores blocks of size dataTable_cache_block_size
    var dataTable_cache_size_max = 100;
    var dataTable_cache_ptr = 0;

    var cache_node = function(st, et, dt) {
        var cache_node = {
            start_time: st,
            end_time: et,
            datatable: dt
        }

        return cache_node;
    }

    var cache_level = function (level, no_of_blocks) {
        var cache_level = [];
        for (var i=0; i<no_of_blocks; i++) {
            cache_level.push(new cache_node(null, null, null));
        }
    }

    // Google library specific loads for all the supported chart types
    google.load("visualization", "1", {packages: ['table', 'motionchart']});
    google.setOnLoadCallback(initViz);

    function initViz() {

        dp_id = parent.window.location.pathname.split('/')[3]
        console.log('dp_id: ', dp_id);

        // Init some variables
        graph_x_res = document.getElementById("graph_div").scrollWidth;
        initSpinner();

        // Init the graph object based on drop down selection
        //setGraphType();

        // Init the overview graph
        data_series_overview = [];
        graph = table = null;
        initOverview();

    }

    function initOverview() {
        /// Get meta data for the data product id. It will be used to retrieve the correct data
        jQuery.ajax ({
            url: container_server + "/visualization/get_dataproduct_metadata/?data_product_id=" + dp_id + "&callback=dp_metadata_cb&return_format=raw_json",
            dataType: 'jsonp',
            jsonpCallback: 'dp_metadata_cb'
        });

    }

    function dp_metadata_cb(response) {
        dp_metadata = response;

        // calculate and init a few things
        avg_data_rate = dp_metadata['time_steps'] / (dp_metadata['time_bounds'][1] - dp_metadata['time_bounds'][0]);
        var tot_num_of_blocks = Math.ceil(dp_metadata['time_steps']/dataTable_cache_block_size);
        dataTable_cache_block_time_period = Math.ceil(dataTable_cache_block_size / avg_data_rate); // ** Is this correct ?

        // calculate the stride factor
        var num_of_actual_data_points = (dp_metadata['time_bounds'][1] - dp_metadata['time_bounds'][0]) * avg_data_rate;
        dataTable_overview_stride_factor = Math.ceil(num_of_actual_data_points / graph_x_res);

        // init cache blocks
        delete dataTable_cache;
        dataTable_cache = {};

        // Calculate the number of cache levels needed. Its a binary tree that starts at the overview and
        // goes down to stride factor 1
        var no_of_cache_levels = Math.ceil(Math.log(dataTable_overview_stride_factor)/Math.log(2) + 1);
        var no_of_cache_level_blocks = 1;
        // Init the cache
        for (var i=no_of_cache_levels - 1; i>=0; i--) {
            var _level = Math.pow(2,i);

            if (_level >= dataTable_overview_stride_factor) {
                _level = dataTable_overview_stride_factor
            }

            dataTable_cache[_level.toString()] = new cache_level(no_of_cache_level_blocks);
            no_of_cache_level_blocks = 4 * no_of_cache_level_blocks;
        }

        var vp = setVizParams(dataTable_parameters, dp_metadata['time_bounds'][0], dp_metadata['time_bounds'][1], dataTable_overview_stride_factor);
        fetchData(vp);
    }


    function fetchData(vp) {

        var query;

        //query = new google.visualization.Query(container_server + "/ion-service/visualization_service/get_visualization_data?data_product_id=" + dp_id + "&visualization_parameters=" + JSON.stringify(viz_params) + "&tqx=reqId:" + _reqId + "&return_format=raw_json");
        query = new google.visualization.Query(container_server + "/visualization/get_visualization_data/?data_product_id=" + dp_id + "&visualization_parameters=" + JSON.stringify(vp) + "&return_format=raw_json",
                {sendMethod:'scriptInjection'});
        console.debug("Fetching data : ", query);

        // Send the query with a callback function.
        query.send(handleDrawQueryResponse);

        // Starter the spinner to tell user that more data is coming
        var spin_target = document.getElementById('graph_div');
        graph_spinner.spin(spin_target);

    }


    function handleDrawQueryResponse(response) {

        if (response.isError()) {
            alert('Error in query: ' + response.getMessage() + ' ' + response.getDetailedMessage());
            return;
        }

        // Translate response in to the format, highstocks understands
        var _dt = response.getDataTable();
        _dt.sort([{column:0}]);

        // If the overview series is empty, assume this is the response to the overview query
        if (data_series_overview.length == 0) {
            dataTable_overview = _dt;
            dataView_overview = new google.visualization.DataView(_dt);
            data_series_overview = gdt_to_highcharts_data(_dt);

            // Call the draw with the first time flag
            drawGraph(data_series_overview, curr_graph_type, true);

            // Create the UI at this point. Now that we have the data
            initGraphUi();
        }
        // Otherwise assume its a higher resolution data set and needs to be merged with the graph
        else {
            var hc_data = gdt_to_highcharts_data(_dt);
            drawGraph(hc_data, curr_graph_type, false);
        }

        // Stop the spinner
        graph_spinner.stop();

    }

    function gdt_to_highcharts_data (_dt) {
        var _hc_data = []
        for (var i=1; i < _dt.getNumberOfColumns(); i++) {

            _hc_data[i-1] = {};
            var _data = [];

            // Create the series data as an array of [timestamp, value]
            for (var j=0; j<_dt.getNumberOfRows(); j++) {
                _data[j] = [_dt.getValue(j,0).getTime(), _dt.getValue(j,i)];
            }

            _hc_data[i-1]["name"] = _dt.getColumnLabel(i);
            _hc_data[i-1]["tooltip"] = {valueDecimals:5};
            _hc_data[i-1]["data"] = _data;
        }

        return _hc_data;
    }


    function drawGraph(_data, _type, first_draw_flag) {
        // Create the chart if the call is being called for the first time

        if (first_draw_flag) {
            if(graph) {
                graph.destroy();
            }

            graph = new Highcharts.StockChart({
                chart : {
                    renderTo : 'graph_div',
                    type: _type,
                    backgroundColor: "#CCCCCC",
                    zoomType: "x"
                },

                title : {
                    text : 'Overview Graph'
                },
                navigator : {
                    adaptToUpdatedData: false,
                    series : {
                        data : _data[0]["data"]
                    }
                },
                legend: {
                    enabled: true,
                    align: 'right',
                    backgroundColor: '#FCFFC5',
                    borderColor: 'black',
                    borderWidth: 2,
                    layout: 'vertical',
                    verticalAlign: 'top',
                    y: 50,
                    shadow: true
                },
                xAxis: {
                    type: 'datetime',
                    events : {
                        afterSetExtremes : onDateRangeChange
                    },
                    minRange: 60 * 1000 // one minute
                },
                yAxis: {
                    labels: {
                        formatter: function() {
                            return (this.value > 0 ? '+' : '') + this.value + '%';
                        }
                    },
                    plotLines: [{
                        value: 0,
                        width: 2,
                        color: 'silver'
                    }]
                },

                plotOptions: {
                    series: {
                        compare: 'value'
                    }
                },
                rangeSelector : {
                    buttons: [{
                        type: 'minute',
                        count: 1,
                        text: '1\''
                    },{
                        type: 'hour',
                        count: 1,
                        text: '1h'
                    }, {
                        type: 'day',
                        count: 1,
                        text: '1d'
                    }, {
                        type: 'month',
                        count: 1,
                        text: '1m'
                    }, {
                        type: 'year',
                        count: 1,
                        text: '1y'
                    }, {
                        type: 'all',
                        text: 'All'
                    }],
                    inputEnabled: true, // it supports only days
                    selected : 5 // all
                },

                series : _data
            });

        }
        // If it was not a first draw, it was the high res data
        else {
            for (var i=0; i < _data.length; i++) {
                graph.series[i].setData(_data[i]["data"], true);

            }
            //graph.redraw();
        }

    }

    function drawTable() {

        if (table) { delete table;}
        $("#graph_div").empty();
        table = new google.visualization.Table(document.getElementById('graph_div'));

        var visible_params_idx_list = [0];
        // create a list of visible parameters reflects the checkboxes
        for (var i=0; i< (dataTable_overview.getNumberOfColumns() - 1); i++) {
            if (graph.series[i]) visible_params_idx_list.push(i+1);
        }

        dataView_overview.setColumns(visible_params_idx_list);
        table.draw(dataView_overview);

    }

    function initGraphUi() {

        // Empty anything in the div before drawing
        $("#graph_ui_div").empty();

        // Populate UI components. Start with the list of parameters. Enclose in a container
        var graphUiDiv = document.getElementById("graph_ui_div");
        var chkBox, paramIdx, graph_type_select, id_str;

        // Create the 'set all' and 'clear all' button
        var check_all_viz_params_button = document.createElement('input');
        check_all_viz_params_button.type = 'button';
        check_all_viz_params_button.value = "Select All Parameters";
        check_all_viz_params_button.addEventListener("click", showAllVizParams);
        graphUiDiv.appendChild(check_all_viz_params_button);

        var clear_all_viz_params_button = document.createElement('input');
        clear_all_viz_params_button.type = 'button';
        clear_all_viz_params_button.value = "De-select All Parameters";
        clear_all_viz_params_button.addEventListener("click", hideAllVizParams);
        graphUiDiv.appendChild(clear_all_viz_params_button);
        graphUiDiv.appendChild(document.createElement('br'));

        // Create a select box for choosing the graph type
        graphUiDiv.appendChild(document.createTextNode('   Graph Type: '));
        graph_type_select = document.createElement('select');
        graph_type_select.setAttribute("id", "graph_type_select");
        graph_type_select.setAttribute("onChange", "onGraphTypeChange(this)");

        var selectFlag = true;
        for (var i=0; i<supported_graph_type.length; i++) {
            graph_type_select.options[i] = new Option(supported_graph_type[i], supported_graph_type[i], selectFlag, false);
            selectFlag = false; // just need it true for the first entry
        }
        graphUiDiv.appendChild(graph_type_select);

        // Page reload button
        graphUiDiv.appendChild(document.createElement('br'));
        var page_reload_button = document.createElement('input');
        page_reload_button.type = 'button';
        page_reload_button.value = "Refresh Chart";
        page_reload_button.addEventListener("click", reloadGraph);
        graphUiDiv.appendChild(page_reload_button);
    }


    function showAllVizParams() {
        // Apparently the last entry in series is for the navigator. So we will ignore that one
        for (var i=0; i < graph.series.length - 1; i++) {
            graph.series[i].show();
        }
    }

    function hideAllVizParams() {
        // Apparently the last entry in series is for the navigator. So we will ignore that one
        for (var i=0; i < graph.series.length - 1; i++) {
            graph.series[i].hide();
        }
    }

    function onGraphTypeChange (selectedOption ) {
        curr_graph_type = selectedOption.value;

        // Redraw the graph
        if (curr_graph_type == 'table') {
            drawTable();
        }
        else {
            drawGraph(data_series_overview, curr_graph_type, true);
        }
    }

    function reloadGraph() {
        initOverview();
    }

    /*


     // ****************************************************************************
     // Caching related methods
     // ****************************************************************************

     // Function gets a list of indexes in the dataTable_cache list which overlap the start_time - end_time
     function getListOfBlocks(start_time, end_time) {

     var listOfBlocks = [];
     var _start_time, _end_time;

     for (var i=0; i < dataTable_cache.length; i++) {
     // Simple checks to see if the block overlaps with passed time period
     if (start_time > dataTable_cache[i].end_time) continue;
     if (end_time < dataTable_cache[i].start_time) continue;

     listOfBlocks[listOfBlocks.length] = i;
     }

     return listOfBlocks;
     }

     // Function gets a list of  of indexes in the dataTable_cache list which overlap the start_time - end_time but
     // are not available in cache
     function getListOfBlocksNeeded(start_time, end_time) {

     var listOfBlocks = getListOfBlocks(start_time, end_time);
     var listOfBlocksNeeded = [];

     // go through the list to see which blocks are missing
     for (var i = 0; i<listOfBlocks.length; i++) {
     if (dataTable_cache[listOfBlocks[i]].datatable == null)
     listOfBlocksNeeded[listOfBlocksNeeded.length] = listOfBlocks[i];
     }

     return listOfBlocksNeeded;
     }

     // Returns true if all the data needed is in cache, Even if one block is missing, it will return false
     function isDataInCache(start_time, end_time, stride_factor) {

     // Is the current zoom level at the high level
     if (stride_factor <= dataTable_level_trigger) {
     var listOfblocks = getListOfBlocksNeeded(start_time, end_time);

     // If all the data is in cache, we should have received an empty list
     if (listOfblocks.length > 0) return false;
     }

     return true; // Since we have an overview of all data
     }

     // This is a weird hacky function which is needed to place the received high datatable in its appropriate place in
     // cache. The lack of a reqId return from google API necessitates the need for this one.
     function insertDataTableInCache(dt) {
     time_range = dt.getColumnRange(0); // get the min and max values of time

     start_time_d = new Date(time_range.min);
     end_time_d = new Date(time_range.max);

     start_time = start_time_d.getTime() / 1000;
     end_time = end_time_d.getTime() / 1000;

     var idx = null;
     var proximity_score = Infinity, temp_score = 0;
     for (var i=0; i < dataTable_cache.length; i++) {
     // Simple checks to see which entry in cache is the best match
     temp_score = Math.abs(dataTable_cache[i].start_time - start_time) +
     Math.abs(dataTable_cache[i].end_time - end_time);

     if(temp_score < proximity_score) {
     proximity_score = temp_score;
     idx = i;
     }
     }

     if (idx != null) {
     dataTable_cache[idx].datatable = dt;
     return idx;
     }
     else {
     console.debug("Error: Could not locate entry for datatable");
     return null;
     }
     }


     function getDatatableRows(dt, start_row, end_row) {

     var rows = [];
     var temp_row = [];

     var num_of_cols = dt.getNumberOfColumns();

     if(start_row == null && end_row == null) {
     start_row = 0;
     end_row = dt.getNumberOfRows() - 1;
     }

     for (var row_idx = start_row; row_idx <= end_row; row_idx++) {
     temp_row = [];
     for (col_idx = 0; col_idx < num_of_cols; col_idx++) {
     if (col_idx == 0)
     temp_row[col_idx] = new Date(dt.getValue(row_idx, col_idx));
     else
     temp_row[col_idx] = dt.getValue(row_idx, col_idx);
     }

     rows[rows.length] = temp_row;
     }

     return rows;

     }
     */

    function onDateRangeChange(e) {

        graph_visible_start_date = e.min;
        graph_visible_end_date = e.max;

        // If the overview itself is at a high enough zoom level, no need to make requests for data
        if (dataTable_overview_stride_factor == 1)
            return;

        // calculate current stride_factor
        var num_of_actual_data_points = (graph_visible_end_date - graph_visible_start_date) * avg_data_rate / 1000;
        curr_stride_factor = Math.ceil(num_of_actual_data_points / graph_x_res);
        console.debug ("curr_stride_factor : ", curr_stride_factor);

        // If we are still at the overview level, do nothing
        if (curr_stride_factor == dataTable_overview_stride_factor)
            return;

        // NO CACHING SCHEME  *************************

        // Draw from local data first while users way for the higher resolution
        for (var i=0; i < data_series_overview.length; i++) {
            graph.series[i].setData(data_series_overview[i]["data"], true);
        }

        var vp = setVizParams(dataTable_parameters,
                Math.round(graph_visible_start_date/1000),
                Math.round(graph_visible_end_date/1000),
                curr_stride_factor);
        fetchData(vp);

        // NO CACHING SCHEME  *************************

    }

    function setVizParams(_dt_params, _start_time, _end_time, _stride_factor) {

        // prep the dictionary
        var viz_params = {};
        viz_params['parameters'] = _dt_params; // Comma separated list of variables to be plotted. If empty,
        // all variables are plotted

        viz_params["start_time"] = _start_time;
        viz_params["end_time"] = _end_time;
        viz_params['stride_time'] = _stride_factor;

        viz_params['use_direct_access'] = 0;  // 1 for yes, 0 for no

        return viz_params;
    }

    function initSpinner() {
        var opts = {
            lines: 13, // The number of lines to draw
            length: 7, // The length of each line
            width: 4, // The line thickness
            radius: 10, // The radius of the inner circle
            corners: 1, // Corner roundness (0..1)
            rotate: 0, // The rotation offset
            color: '#000', // #rgb or #rrggbb
            speed: 1, // Rounds per second
            trail: 60, // Afterglow percentage
            shadow: false, // Whether to render a shadow
            hwaccel: false, // Whether to use hardware acceleration
            className: 'spinner', // The CSS class to assign to the spinner
            zIndex: 2e9, // The z-index (defaults to 2000000000)
            top: 'auto', // Top position relative to parent in px
            left: 'auto' // Left position relative to parent in px
        };

        graph_spinner = new Spinner(opts);
    }


    </script>
  </head>

  <div class='chart-google' style="position:relative;">
      <div id="graph_div" style="width:100%;height:300px;"></div>
      <!-- <form> -->
      <div id="graph_ui_div" style="color:#ccc;font-family:sans-serif;font-size:11px;text-transform:uppercase;position:relative;top:0;right:0;width:100%;"></div>
      <!-- </form> -->
  </div>




  <!-- HTML code and UI components etc -->

